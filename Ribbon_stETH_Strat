// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

contract Ribbon_stETH_Covered_Calls {
   //Interface with RBN token
    ISTETH stETH;
    address DAO_Treasury;
    IRibbon rstETH_TV;
    IrstETH_Theta_Gauge rstETH_TGV; 
    //Need to interface to RBN Token at some point.
    
    
    /* Work to be done: 5/9/2022: 
      * Interface with RBN token - steal it from somewhere: not done
    * Figure out difference between ClaimableRewards and ClaimableTokens: not done
      * Make a withdrawal function to withdraw RBN rewards: not done
         * 1. Check how much RBN there is pending
         * 2. Withdraw the RBN
       * Make a function to check for special rewards (manual): not done
       *Make a function to withdraw that special reward (manual) not done
      * Add to IRibbon interface the function to allow manual stETH re-entry into the contract: not done
      * Interface to stETH: not done
      * Write a function to send stETH back to the DAO: not done
           * Include this function in the 'CompleteWithdrawingAndRetrieveSTETH': not done
    */
    
    
    constructor() {
      //RBN = 
        stETH = ISTETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84); //stETH address
        DAO_Treasury = 0x7E3Ee99EC9b2aBd42c8c8504dc8195C8dc4942D0; // currently my testnet address - Change to the DAO Address
        rstETH_TV = IRibbon(0x53773E034d9784153471813dacAFF53dBBB78E8c); // Ribbon stETH Covered Call vault option
        rstETH_TGV = IrstETH_Theta_Gauge(0x4e079dCA26A4fE2586928c1319b20b1bf9f9be72); // Ribbon stETh Covered Call Gauge Token vault
    }

    // modifier to check if caller is the Tribe DAO or not
    modifier isDAO() {
        require(msg.sender == DAO_Treasury, "You aren't part of the DAO...");
        _;
    }

    /* This financial strategy has two primary layers to it.
    * The first layer consists of a deposit of raw ETH into the rstETH-Theta vault. The raw ETH is turned into stETH by RBN before depositing.
    * Now this stETH is sitting inside the rstETH-Theta vault in the form of rstETH-Theta. This is the first layer of investment. 
    * To enter the second layer of investment and earn more rewards requires calling the Stake function on the first layer contract.
    * The stake function sends the rstETH-Theta to the rstETH-Theta-Gauge vault and gives the sender rstETH-Theta-Gauge tokens. 
    * Now the investment is in its second layer and holding the rstETH-Theta-Gauge tokens allows the contract access to RBN rewards. 
    * To undo the investment requires first withdrawing from the second layer via calling the Withdraw function on the rstETH-Theta-Gauge contract.
    * Then to undo the first layer requires calling the InitializeWithdraw function before then calling the CompleteWithdraw function.
    */

     //Now we get into Layer One and Layer Two functions. All the Multi-step functions build ontop of these functions. 
    
    /*
    *<LAYER ONE FUNCTIONS> Interacting with the rstETH-Theta Vault contract
    */
    function deposit_stETH() external isDAO payable{ //Note: if the DAO withdraws and then decides to go back, the assets originally used are now stETH, so we use a different function
        //rstETH_TV.depositETH(); Need to turn this into depositing stETH for when the DAO withdraws and then decides to do it again
    } //deposit the ETH into the RBN contract and create the first layer
    
     function layerOneBalanceCheck() external view isDAO returns (uint256){
     uint256 balance = rstETH_TV.balanceOf(address(this));
      return balance;
    } // code way to check our contract's balance of the rstETH-Theta token

    function checkVaultBalance() external isDAO view returns(uint256 _returnVal) {
      _returnVal = rstETH_TV.shares(msg.sender);
    } //helper function for obtaining the number of shares we have in layer one vault, independently available 
    
    function stake(uint256 sharesToStake) external isDAO { 
      rstETH_TV.stake(sharesToStake);
    } // stakes the shares we have in layer one and puts them ito layer two
  
    function layerOneWithdraw(uint256 amtToWithdraw) external isDAO {
      rstETH_TV.initiateWithdraw(amtToWithdraw);
    } //begin Layer One withdrawal process, marks your shares to be excluded from the next minting option.    \
    //REMOVE THIS LATER: For MultiCall purposes: note that because we have unstaked from layer two at this point, we call balanceOf and not checkVaultBalance since our vault shares are already redeemed (ie. held by the contract and not inside the RBN vault)
    
    function finishLayerOneWithdraw() external isDAO {
      rstETH_TV.completeWithdraw();
    } //complete Layer One withdrawal process, can occur once the next vault option has been minted and your tokens were excluded - 10:00am UTC on Fridays
    /*
    *<LAYER ONE FUNCTIONS END>
    */
    
    /*
    *<LAYER TWO START> Interacting with the rstETH-Theta-Gauge Vault contract
    */
   function layerTwoBalanceCheck() external view isDAO returns (uint256){
     uint256 balance = rstETH_TGV.balanceOf(address(this));
     return balance;
   } // code way to check our contract's balance of the rstETH-Theta-Gauge token

    function layerTwoWithdraw(uint256 _value, bool claim_rewards) external isDAO{
      rstETH_TGV.withdraw(_value, claim_rewards);
    } //withdraw from Layer Two - exchange rstETH-Theta-Gauge for rstETH-Theta
    
    function layerTwoDeposit(uint256 _value, address _addr, bool _claim_rewards) external isDAO { //make sure _addr is msg.sender
        rstETH_TGV.deposit(_value, _addr, _claim_rewards);
    } //this function is what is actually called on the Layer Two contract by the Stake function on Layer One (shares must be redeemed to call this function)
     //I am adding this for the rare but possible instance where the DAO has withdrawn from Layer Two and then wants to go back instead of continuing to withdraw from Layer one
    
    //function userCheckpoint ?????

   /*
   *<LAYER TWO END>
   */


       /* <Multi-Step Calls> 
   *These calls are intended to be used by the DAO for simplicitie's sake by stacking as many Layer One and Layer Two functions into one single action
   * I understand that having all the different Layer functions increase initial contract deployment cost simply because there are more characters for the EVM to gas profile, let alone stacking pre-built functions.
   * However, I felt it prudent to leave the oppurtunity to call functions step-by-step if neccessary, instead of leaving a crucial function within a multi-step call.
   *This also makes the DAO's investment strategy more tailorable and able to shift from Layer One to Layer Two and back. 
   */  
  
    function LetsBegin_DepositETH() external isDAO payable { //NOTE NOTE NOTE: Investigate how payable functions work
      rstETH_TV.depositETH(); 
      //Event here saying ETH was deposited.
    } //deposit the ETH into the RBN contract and create the first layer

    function stakeNow() external isDAO {
      uint256 _balance = this.checkVaultBalance();
      require(_balance != 0, 'There is no balance within the vault yet.');    
        this.stake(_balance);
        //Event here to say that staking occured
    }

    //Want to make sure that all of these functions can actually occur instantaneously....
    function BeginWithdrawing() external isDAO {
      uint256 _balance = this.layerTwoBalanceCheck(); // check our balance
      this.layerTwoWithdraw(_balance, true);  //withdraw our balance from the second layer
      this.layerOneWithdraw(_balance); //Begin our withdrawal process from the first layer
      //Event to say we began withdrawing
    } 

    //Important, only call this when the next vault option is minted and your shares are returned in the form of stETH
    function CompleteWithdrawingAndRetrieveSTETH() external isDAO { 
      this.finishLayerOneWithdraw();
      uint256 _balanceOfstETH = stETH.balanceOf(address(this)); // check our stETH balance
      stETH.approve(DAO_Treasury, _balanceOfstETH); //approve the treasury to receive our balance
      stETH.transferFrom(address(this), DAO_Treasury, _balanceOfstETH); // transfer the balance to the DAO treasury

      //Event to say that we completedthewithdrawing
    }

   //Need a function for claiming rewards, problem occuring here is
   //On the Gauge contract there claimable_tokens and then there is claimable_rewards
   //Need to determine the differences between them 
}


interface IRibbon { //Interface with the ribbon contract
  //Deposit - deposit ETH to be minted into vault shares, - Layer 1
  function depositETH() external payable;

  /*
  * Need to interface to the other deposit function for stETH
  */

 //RibbonVault.shares - get the # of shares we have in the vault - Layer 1
  //NOTE: this function is placeholder until confirmation that this is the proper way to read a readable value?
  function shares(address) external view returns (uint256);

 //Stake - stake the shares into the rstETH-Theta-Gauge vault, you receive rstETH-Theta-Gauge - Layer 1
  function stake(uint256) external;

 //InitializeWithdraw - begins the withdrawal process, marks your shares to not be included in the next option round (occurs at 10:00 am UTC) - Layer 1
  function initiateWithdraw(uint256) external;

 //CompleteWithdraw - finishes the withdrawal process, only callabled after you initialized the withdrawl and the option round has concluded - Layer 1
  function completeWithdraw() external;

 //balanceOf - checks our balance of rstETH-Theta if the shares are redeemed (not inside the vault), shares recently withdrawn from staking program will not be inside the vault - making this neccessary
  function balanceOf(address) external view returns (uint256);

 //redeem - redeems the tokens from the vault for this contract to hold its rstETH-Theta directly (function exists just in case)
 function redeem(uint256) external;

 //maxRedeem - redeems the maximum amount of tokens from the vault
 function maxRedeem() external ;
}

interface IrstETH_Theta_Gauge {  //Interfacing with rstETH-Theta-Gauge - this contract is written in Vyper...fuck me 
    //balanceOf - checks to see the current balance of rstETH-Theta-Gauge tokens
    function balanceOf(address) external view returns (uint256);

    //Withdraw - takes your rstETH-Theta-Gauge and burns it, giving you your rstETH-Theta back. Layer 2 withdrawal.
    function withdraw(uint256, bool) external; 
      /* How "Withdraw" looks on the Layer Two contract: yes I am putting this here to make it easier for people to vet my code since I'm uncomfy with Vyper
       * 
       * @external
       * @nonreentrant('lock')
       * def withdraw(_value: uint256, _claim_rewards: bool = False): 
       */

    //ClaimableRewards - see what we can actually claim, views function
    function claimable_rewards(address, address) external view returns (uint256);
      /* same shit, lack confidence, need to keep reference to Vyper code on page
      *@view
      *@external
      *def claimable_reward(_user: address, _reward_token: address) -> uint256:
      */
      
      //WHAT IS DIFFERENCE BETWEEN CLAIMABLE TOKENS AND CLAIMABLE REWARD TOKENS??? BOTH ARE EXTERNAL FUNCTIONS AND RETURN A UINT256
      //There is ClaimableRewards and then ClaimableTokens....

    //ClaimRewards - claiming the RBN rewards
      function claim_rewards() external;
    //function claim_rewards(address, address) external; - I originally wrote this but I believe this version is only neccessary if you have set a specific receiver of your rewards
      /* How the "claim_rewards" function looks on the Layer Two contract: yes this is because I lack confidence in reading Vyper...same old same old
      *
      *@external
      *@nonreentrant('lock')
      *def claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):
      */

    //User_Checkpoint - boosts rewards on Locked RBN tokens. This contract does not lock the RBN token.

    //Deposit - the function that allows the user to deposit into the Gauge vault - called by the "Stake" function in Layer one
    function deposit(uint256 _value, address _addr, bool _claim_rewards) external;  //value = number of tokens depositing, address of depositer, do you claim any pending rewards on rst-ETH-Theta-Gauge?
        //No need to be uncomfortable with how this one works because I found it on the Layer One contract's interface to the layer two contract
}

interface RBNtoken {
    //need to interface with the RBN token to allow our contract to send the RBN rewards elsewhere
    
}

  interface ISTETH { //Ribbon allows you to put in raw ETH but withdrawing gives you stETH, so we need to be able to move that stETH out
    function getBufferedEther(uint256 _amount) external view returns (uint256);
    function getPooledEthByShares(uint256 _amount)
        external
        view
        returns (uint256);
    function getSharesByPooledEth(uint256 _amount)
        external
        view
        returns (uint256);
    function submit(address _referralAddress)
        external
        payable
        returns (uint256);
    function withdraw(uint256 _amount, bytes32 _pubkeyHash)
        external
        returns (uint256);
    function approve(address _recipient, uint256 _amount)
        external
        returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    function decimals() external view returns (uint256);
    function getTotalShares() external view returns (uint256);
    function getTotalPooledEther() external view returns (uint256);
}
