// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

contract Ribbon_stETH_Covered_Calls {
   //Interface with RBN token
    IRBNtoken RBN;
    ISTETH stETH;
    address DAO_Treasury;
    IRibbon rstETH_TV;
    IrstETH_Theta_Gauge rstETH_TGV; 
    //Need to interface to RBN Token at some point.
    
    
    /* Work to be done: 5/9/2022: 
      * Interface with RBN token - steal it from somewhere: not done
    * Figure out difference between ClaimableRewards and ClaimableTokens: Done
      * Make a withdrawal function to withdraw RBN rewards: not done
         * 1. Check how much RBN there is pending
         * 2. Withdraw the RBN
       * Make a function to check for reward amount: done
       *Make a function to withdraw rewards: not done
      * Add to IRibbon interface the function to allow manual stETH re-entry into the contract: not done
      * Interface to stETH: not done
      * Write a function to send stETH back to the DAO: not done
           * Include this function in the 'CompleteWithdrawingAndRetrieveSTETH': not done
    */
    
    
    constructor() {
        RBN = IRBNtoken(0x6123B0049F904d730dB3C36a31167D9d4121fA6B); //RBN token address - double check before deploying
        stETH = ISTETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84); //stETH address - double check before deploying
        DAO_Treasury = 0x7E3Ee99EC9b2aBd42c8c8504dc8195C8dc4942D0; // currently a testnet address - Change to the DAO Address
        rstETH_TV = IRibbon(0x53773E034d9784153471813dacAFF53dBBB78E8c); // Ribbon stETH Covered Call vault option
        rstETH_TGV = IrstETH_Theta_Gauge(0x4e079dCA26A4fE2586928c1319b20b1bf9f9be72); // Ribbon stETh Covered Call Gauge Token vault
    }

    // modifier to check if caller is the Tribe DAO or not
    modifier isDAO() {
        require(msg.sender == DAO_Treasury, "You aren't part of the DAO...");
        _;
    }

    /* This financial strategy has two primary layers to it.
    * The first layer consists of a deposit of raw ETH into the rstETH-Theta vault. The raw ETH is turned into stETH by RBN before depositing.
    * Now this stETH is sitting inside the rstETH-Theta vault in the form of rstETH-Theta. This is the first layer of investment. 
    * To enter the second layer of investment and earn more rewards requires calling the Stake function on the first layer contract.
    * The stake function sends the rstETH-Theta to the rstETH-Theta-Gauge vault and gives the sender rstETH-Theta-Gauge tokens. 
    * Now the investment is in its second layer and holding the rstETH-Theta-Gauge tokens allows the contract access to RBN rewards. 
    * To undo the investment requires first withdrawing from the second layer via calling the Withdraw function on the rstETH-Theta-Gauge contract.
    * Then to undo the first layer requires calling the InitializeWithdraw function before then calling the CompleteWithdraw function.
    */

     //Now we get into Layer One and Layer Two functions. All the Multi-step functions build ontop of these functions. 
    
    /*
    *<LAYER ONE FUNCTIONS> Interacting with the rstETH-Theta Vault contract
    */
    function deposit_stETH() external isDAO payable{ //Note: if the DAO withdraws and then decides to go back, the assets originally used are now stETH, so we use a different function
        //rstETH_TV.depositETH(); Need to turn this into depositing stETH for when the DAO withdraws and then decides to do it again
    } //deposit the ETH into the RBN contract and create the first layer
    
     function layerOneBalanceCheck() external view isDAO returns (uint256){
     uint256 balance = rstETH_TV.balanceOf(address(this));
      return balance;
    } // code way to check our contract's balance of the rstETH-Theta token

    function checkVaultBalance() external isDAO view returns(uint256 _returnVal) {
      _returnVal = rstETH_TV.shares(msg.sender);
    } //helper function for obtaining the number of shares we have in layer one vault, independently available 
    
    function stake(uint256 sharesToStake) external isDAO { 
      rstETH_TV.stake(sharesToStake);
    } // stakes the shares we have in layer one and puts them ito layer two
  
    function layerOneWithdraw(uint256 amtToWithdraw) external isDAO {
      rstETH_TV.initiateWithdraw(amtToWithdraw);
    } //begin Layer One withdrawal process, marks your shares to be excluded from the next minting option.    \
    //REMOVE THIS LATER: For MultiCall purposes: note that because we have unstaked from layer two at this point, we call balanceOf and not checkVaultBalance since our vault shares are already redeemed (ie. held by the contract and not inside the RBN vault)
    
    function finishLayerOneWithdraw() external isDAO {
      rstETH_TV.completeWithdraw();
    } //complete Layer One withdrawal process, can occur once the next vault option has been minted and your tokens were excluded - 10:00am UTC on Fridays
    /*
    *<LAYER ONE FUNCTIONS END>
    */
    
    /*
    *<LAYER TWO START> Interacting with the rstETH-Theta-Gauge Vault contract
    */
   function layerTwoBalanceCheck() external view isDAO returns (uint256){
     uint256 balance = rstETH_TGV.balanceOf(address(this));
     return balance;
   } // code way to check our contract's balance of the rstETH-Theta-Gauge token

    function layerTwoWithdraw(uint256 _value, bool claim_rewards) external isDAO{
      rstETH_TGV.withdraw(_value, claim_rewards);
    } //withdraw from Layer Two - exchange rstETH-Theta-Gauge for rstETH-Theta
    
    function layerTwoDeposit(uint256 _value, address _addr, bool _claim_rewards) external isDAO { //make sure _addr is msg.sender
        rstETH_TGV.deposit(_value, _addr, _claim_rewards);
    } //this function is what is actually called on the Layer Two contract by the Stake function on Layer One (shares must be redeemed to call this function)
     //I am adding this for the rare but possible instance where the DAO has withdrawn from Layer Two and then wants to go back instead of continuing to withdraw from Layer one
    
    function checkCAR(address token) view external isDAO returns (uint256 _returnVal){
        _returnVal = rstETH_TGV.claimable_rewards(msg.sender, token);
        return _returnVal;
   }//Check how much of a specific reward token we can claim. It should just be RBN token

   function claim_ze_rewardz() external isDAO{
     rstETH_TGV.claim_rewards();
   } //Claim our rewards

   /*
   *<LAYER TWO END>
   */


       /* <Multi-Step Calls> 
   *These calls are intended to be used by the DAO for simplicitie's sake by stacking as many Layer One and Layer Two functions into one single action
   * I understand that having all the different Layer functions increase initial contract deployment cost simply because there are more characters for the EVM to gas profile, let alone stacking pre-built functions.
   * However, I felt it prudent to leave the oppurtunity to call functions step-by-step if neccessary, instead of leaving a crucial function within a multi-step call.
   *This also makes the DAO's investment strategy more tailorable and able to shift from Layer One to Layer Two and back. 
   */  
  
    function LetsBegin_DepositETH() external isDAO payable { //NOTE NOTE NOTE: Investigate how payable functions work
      rstETH_TV.depositETH(); 
      //Event here saying ETH was deposited.
    } //deposits the ETH into the RBN contract and create the first layer

    function stakeNow() external isDAO {
      uint256 _balance = this.checkVaultBalance();
      require(_balance != 0, 'There is no balance within the vault yet.');    
        this.stake(_balance);
        //Event here to say that staking occured
    } // If we have a balance within the RBN vault, stake it.

    //Want to make sure that all of these functions can actually occur instantaneously....Ask Log 
    //^^^^^^^^^^^^^^^^ASK LOG LOG LOG LOG LOG LOG LOG 
    function BeginWithdrawing() external isDAO {
      uint256 _balance = this.layerTwoBalanceCheck(); // check our balance
      this.layerTwoWithdraw(_balance, true);  //withdraw our balance from the second layer
      this.layerOneWithdraw(_balance); //Begin our withdrawal process from the first layer
      //Event to say we began withdrawing
    }//First withdraw our balance from the second layer. Then begin withdrawing from the first layer

    //Important, only call this when the next vault option is minted with your shares excluded.
    function CompleteWithdrawingAndRetrieveSTETH() external isDAO { 
      this.finishLayerOneWithdraw();
      uint256 _balanceOfstETH = stETH.balanceOf(address(this)); // check our stETH balance
      stETH.approve(DAO_Treasury, _balanceOfstETH); //approve the treasury to receive our balance
      stETH.transferFrom(address(this), DAO_Treasury, _balanceOfstETH); // transfer the balance to the DAO treasury
      //Event to say that we completedthewithdrawing

    } //Finishes the withdrawal process

    function Claim_RBN_Rewards() external isDAO{
      uint256 rewards = this.checkCAR();
      require(rewards != 0, "There are no claimable rewards");

    }
}


interface IRibbon { //Interface with the ribbon contract
  //Deposit - deposit ETH to be minted into vault shares, - Layer 1
  function depositETH() external payable;

  /*
  * Need to interface to the other deposit function for stETH
  */

 //RibbonVault.shares - get the # of shares we have in the vault - Layer 1
  //NOTE: this function is placeholder until confirmation that this is the proper way to read a readable value?
  function shares(address) external view returns (uint256);

 //Stake - stake the shares into the rstETH-Theta-Gauge vault, you receive rstETH-Theta-Gauge - Layer 1
  function stake(uint256) external;

 //InitializeWithdraw - begins the withdrawal process, marks your shares to not be included in the next option round (occurs at 10:00 am UTC) - Layer 1
  function initiateWithdraw(uint256) external;

 //CompleteWithdraw - finishes the withdrawal process, only callabled after you initialized the withdrawl and the option round has concluded - Layer 1
  function completeWithdraw() external;

 //balanceOf - checks our balance of rstETH-Theta if the shares are redeemed (not inside the vault), shares recently withdrawn from staking program will not be inside the vault - making this neccessary
  function balanceOf(address) external view returns (uint256);

 //redeem - redeems the tokens from the vault for this contract to hold its rstETH-Theta directly (function exists just in case)
 function redeem(uint256) external;

 //maxRedeem - redeems the maximum amount of tokens from the vault
 function maxRedeem() external ;
}

interface IrstETH_Theta_Gauge {  //Interfacing with rstETH-Theta-Gauge - this contract is written in Vyper...fuck me 
    //balanceOf - checks to see the current balance of rstETH-Theta-Gauge tokens
    function balanceOf(address) external view returns (uint256);

    //Withdraw - takes your rstETH-Theta-Gauge and burns it, giving you your rstETH-Theta back. Layer 2 withdrawal.
    function withdraw(uint256, bool) external; 
      /* How "Withdraw" looks on the Layer Two contract: yes I am putting this here to make it easier for people to vet my code since I'm uncomfy with Vyper
       * 
       * @external
       * @nonreentrant('lock')
       * def withdraw(_value: uint256, _claim_rewards: bool = False): 
       */

    //ClaimableRewards - see what we can actually claim, views function
    function claimable_rewards(address, address) external view returns (uint256);
      /* same shit, lack confidence, need to keep reference to Vyper code on page
      *@view
      *@external
      *def claimable_reward(_user: address, _reward_token: address) -> uint256:
      */

    //ClaimRewards - claiming the RBN rewards
      function claim_rewards() external;
     // function claim_rewards(address, address) external; More complicated version
      /* How the "claim_rewards" function looks on the Layer Two contract: yes this is because I lack confidence in reading Vyper...same old same old
      *
      *@external
      *@nonreentrant('lock')
      *def claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):
      */

    //User_Checkpoint - boosts rewards on Locked RBN tokens. This contract does not lock the RBN token.

    //Deposit - the function that allows the user to deposit into the Gauge vault - called by the "Stake" function in Layer one
    function deposit(uint256 _value, address _addr, bool _claim_rewards) external;  //value = number of tokens depositing, address of depositer, do you claim any pending rewards on rst-ETH-Theta-Gauge?
    //No need to be uncomfortable with how this one works because I found it on the Layer One contract's interface to the layer two contract
}

interface IRBNtoken {
    //need to interface with the RBN token to allow our contract to send the RBN rewards elsewhere
    
}

  interface ISTETH { //Ribbon allows you to put in raw ETH but withdrawing gives you stETH, so we need to be able to move that stETH out
    function getBufferedEther(uint256 _amount) external view returns (uint256);
    function getPooledEthByShares(uint256 _amount)
        external
        view
        returns (uint256);
    function getSharesByPooledEth(uint256 _amount)
        external
        view
        returns (uint256);
    function submit(address _referralAddress)
        external
        payable
        returns (uint256);
    function withdraw(uint256 _amount, bytes32 _pubkeyHash)
        external
        returns (uint256);
    function approve(address _recipient, uint256 _amount)
        external
        returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    function decimals() external view returns (uint256);
    function getTotalShares() external view returns (uint256);
    function getTotalPooledEther() external view returns (uint256);
}
