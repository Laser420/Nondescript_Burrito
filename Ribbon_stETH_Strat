// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

contract Ribbon_stETH_Covered_Calls {
    address DAO_Treasury;
    IRibbon rstETH_TV_Interface;
    IrstETH_Theta_Gauge rstETH_TGV_Interface; 
    //Need to interface to RBN Token at some point.
    
    constructor() {
        DAO_Treasury = 0x7E3Ee99EC9b2aBd42c8c8504dc8195C8dc4942D0; // currently my testnet address - Change to the DAO Address
        rstETH_TV_Interface = IRibbon(0x53773E034d9784153471813dacAFF53dBBB78E8c); // Ribbon stETH Covered Call vault option
        rstETH_TGV_Interface = IrstETH_Theta_Gauge(0x4e079dCA26A4fE2586928c1319b20b1bf9f9be72); // Ribbon stETh Covered Call Gauge Token vault
    }

    // modifier to check if caller is the Tribe DAO or not
    modifier isDAO() {
        require(msg.sender == DAO_Treasury, "You aren't part of the DAO...");
        _;
    }

    /* This financial strategy has two primary layers to it.
    * The first layer consists of a deposit of raw ETH into the rstETH-Theta vault. The raw ETH is turned into stETH by RBN before depositing.
    * Now this stETH is sitting inside the rstETH-Theta vault in the form of rstETH-Theta. This is the first layer of investment. 
    * To enter the second layer of investment and earn more rewards requires calling the Stake function on the first layer contract.
    * The stake function sends the rstETH-Theta to the rstETH-Theta-Gauge vault and gives the sender rstETH-Theta-Gauge tokens. 
    * Now the investment is in its second layer and holding the rstETH-Theta-Gauge tokens allows the contract access to RBN rewards. 
    * To undo the investment requires first withdrawing from the second layer via calling the Withdraw function on the rstETH-Theta-Gauge contract.
    * Then to undo the first layer requires calling the InitializeWithdraw function before then calling the CompleteWithdraw function.
    */ 
    
    //<Layer One>
    // function DepositTheETH - deposit the ETH into the RBN contract and create the first layer
   
    //function checkVaultBalance -  helper function for obtaining the number of shares we have in layer one vault, independently available 
    
    //function stake - stakes the shares we have in layer one and puts them ito layer two
  
    //function layerOneWithdraw - begin Layer One withdrawal process, note that because we have unstaked from layer two at this point, we call balanceOf and not checkVaultBalance since our vault shares are already redeemed (ie. held by the contract and not inside the RBN vault)
    
    //function finishLayerOneWithdraw - complete Layer One withdrawal process
    
    //<Layer One End>
    
    
    //<Layer Two>    
    //function layerTwoWithdraw - withdraw from Layer Two - exchange rstETH-Theta-Gauge for rstETH-Theta
    
    //function layerTwoDeposit - this function is what is actually called internally within the Stake function once shares are redeemed
                       //I am adding this for the rare but possible instance where the DAO has withdrawn from Layer Two and then wants to go back instead of continuing to withdraw from Layer one
    
    //function userCheckpoint ?????
   //<Layer Two End>
   
   
   /* <Multi-Step Calls> 
   *These calls are intended to be used by the DAO for simplicities sake by stacking as many Layer One and Layer Two functions into one single action
   * I understand that this increases initial contract deployment cost simply because there are more characters for the EVM to gas profile, let alone stacking pre-built functions.
   * However, I felt it prudent to leave the oppurtunity to call functions step-by-step if neccessary, instead of leaving a crucial function within a multi-step call.
   *This also makes the DAO's investment strategy more tailorable and able to shift from Layer One to Layer Two and back. 
   */  
   
   //Haven't finished profiling these out yet.
   
   //<Multi-Step Calls End>
}


interface IRibbon { //Interface with the ribbon contract
 //Deposit - deposit ETH to be minted into vault shares, - Layer 1
 function depositETH() external payable;

 //RibbonVault.shares - get the # of shares we have in the vault - Layer 1


 //Stake - stake the shares into the rstETH-Theta-Gauge vault, you receive rstETH-Theta-Gauge - Layer 1
  function stake(uint256) external;

 //InitializeWithdraw - begins the withdrawal process, marks your shares to not be included in the next option round (occurs at 10:00 am UTC) - Layer 1
  function initiateWithdraw(uint256) external;

 //CompleteWithdraw - finishes the withdrawal process, only callabled after you initialized the withdrawl and the option round has concluded - Layer 1
  function completeWithdraw() external;

 //balanceOf - checks our balance of rstETH-Theta if the shares are redeemed (not inside the vault), shares recently withdrawn from staking program will not be inside the vault - making this neccessary
  function balanceOf(address) external view returns (uint256);

 //redeem - redeems the tokens from the vault for this contract to hold its rstETH-Theta directly (function exists just in case)
 function redeem(uint256) external;

 //maxRedeem - redeems the maximum amount of tokens from the vault
 function maxRedeem() external ;
       

}

interface IrstETH_Theta_Gauge {  //Interfacing with rstETH-Theta-Gauge - this contract is written in Vyper...fuck me 
    //balanceOf - checks to see the current balance of rstETH-Theta-Gauge tokens
    function balanceOf(address) external view returns (uint256);

    //Withdraw - takes your rstETH-Theta-Gauge and burns it, giving you your rstETH-Theta back. Layer 2 withdrawal.
    function withdraw(uint256, bool) external; 
 /* How "Withdraw" looks on the Layer Two contract: yes I am putting this here to make it easier for people to vet my code since I'm uncomfy with Vyper
 * 
 * @external
 * @nonreentrant('lock')
 * def withdraw(_value: uint256, _claim_rewards: bool = False): 
 */

    //ClaimableRewards - see what we can actually claim, views function
    function claimable_rewards(address, address) external view returns (uint256);
/* same shit, lack confidence, need to keep reference to Vyper code on page
*@view
*@external
*def claimable_reward(_user: address, _reward_token: address) -> uint256:
*/

    //ClaimRewards - claiming the RBN rewards
    function claim_rewards(address, address) external; 
/* How the "claim_rewards" function looks on the Layer Two contract: yes this is because I lack confidence in reading Vyper...same old same old
 *
 *@external
 *@nonreentrant('lock')
 *def claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):
 */

    //User_Checkpoint?????? Only one I don't understand yet - ask on RBN discord

    //Deposit - the function that allows the user to deposit into the Gauge vault - called by the "Stake" function in Layer one
    function deposit(uint256 _value, address _addr, bool _claim_rewards) external;
    //No need to be uncomfortable with how this one works because I found it on the Layer One contract's interface to the layer two contract
}

interface RBN {
    //need to interface with the RBN token to allow our contract to send the RBN rewards elsewhere
    
}

//ERC20 interface neccessary for interacting with ERC20 tokens
interface IERC20 {
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender)
    external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value)
    external returns (bool);
  function transferFrom(address from, address to, uint256 value)
    external returns (bool);
  event Transfer(
    address indexed from,
    address indexed to,
    uint256 value
  );
  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );
}
