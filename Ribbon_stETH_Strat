// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

contract Ribbon_stETH_Covered_Calls {
    address DAO_Treasury;
    IRibbon Ribbon_IR;
  //IRibbonThetaSTETHVault Ribbon_TSV; - eventually will be interface to rstETH-Theta-Gauge vault
    
    constructor() {
        DAO_Treasury = 0x7E3Ee99EC9b2aBd42c8c8504dc8195C8dc4942D0; // currently my testnet address - Change to the DAO Address
        Ribbon_IR = IRibbon(0x53773E034d9784153471813dacAFF53dBBB78E8c); // Ribbon stETH Covered Call vault option
    }

    // modifier to check if caller is the Tribe DAO or not
    modifier isDAO() {
        require(msg.sender == DAO_Treasury, "You aren't part of the DAO...");
        _;
    }

    /* This financial strategy has two primary layers to it.
    * The first layer consists of a deposit of raw ETH into the rstETH-Theta vault. The raw ETH is turned into stETH by RBN before depositing.
    * Now this stETH is sitting inside the rstETH-Theta vault in the form of rstETH-Theta. This is the first layer of investment. 
    * To enter the second layer of investment and earn more rewards requires calling the Stake function on the first layer contract.
    * The stake function sends the rstETH-Theta to the rstETH-Theta-Gauge vault and gives the sender rstETH-Theta-Gauge tokens. 
    * Now the investment is in its second layer and holding the rstETH-Theta-Gauge tokens allows the contract access to RBN rewards. 
    * To undo the investment requires first withdrawing from the second layer via calling the Withdraw function on the rstETH-Theta-Gauge contract.
    * Then to undo the first layer requires calling the InitializeWithdraw function before then calling the CompleteWithdraw function.
    */ 
    
    //<Layer One>
    // function DepositTheETH - deposit the ETH into the RBN contract and create the first layer
   
    //function checkVaultBalance -  helper function for obtaining the number of shares we have in layer one vault, independently available 
    
    //function stake - stakes the shares we have in layer one and puts them ito layer two
  
    //function layerOneWithdraw - begin Layer One withdrawal process, note that because we have unstaked from layer two at this point, we call balanceOf and not checkVaultBalance since our vault shares are already redeemed (ie. held by the contract and not inside the RBN vault)
    
    //function finishLayerOneWithdraw - complete Layer One withdrawal process
    
    //<Layer One End>
    
    
    //<Layer Two>    
    //function layerTwoWithdraw - withdraw from Layer Two - exchange rstETH-Theta-Gauge for rstETH-Theta
    
    //function layerTwoDeposit - this function is what is actually called internally within the Stake function once shares are redeemed
                                //I am adding this for the rare but possible instance where the DAO has withdrawn from Layer Two and then wants to go back instead of continuing to withdraw from Layer one
    
    //function userCheckpoint ?????
   //<Layer Two End>
   
   
   /* <Multi-Step Calls> 
   *These calls are intended to be used by the DAO for simplicities sake by stacking as many Layer One and Layer Two functions into one single action
   * I understand that this increases initial contract deployment cost simply because there are more characters for the EVM to gas profile, let alone stacking pre-built functions.
   * However, I felt it prudent to leave the oppurtunity to call functions step-by-step if neccessary, instead of leaving a crucial function within a multi-step call.
   */ This also makes the DAO's investment strategy more tailorable and able to shift from Layer One to Layer Two and back. 
   
   //Haven't finished profiling these out yet.
   
   //<Multi-Step Calls End>
}


interface IRibbon {
 //Interface with the ribbon contract
 
 //Deposit - deposit shares into the vault, - Layer 1
 //RibbonVault.shares - get the # of shares we have in the vault - Layer 1
 //Stake - stake the shares into the rstETH-Theta-Gauge vault, you receive rstETH-Theta-Gauge - Layer 1
 //InitializeWithdraw - begins the withdrawal process, marks your shares to not be included in the next option round (occurs at 10:00 am UTC) - Layer 1
 //CompleteWithdraw - finishes the withdrawal process, only callabled after you initialized the withdrawl and the option round has concluded - Layer 1
 //balanceOf - checks our balance of rstETH-Theta if the shares are redeemed (not inside the vault)
 
}

//interface IrstETH-Theta-Gauge { 
     //Interfacing with rstETH-Theta-Gauge - this contract is written in Vyper...fuck me 
    //Withdraw - takes your rstETH-Theta-Gauge and burns it, giving you your rstETH-Theta back. Layer 2 withdrawal.
    //balanceOf - checks to see the current balance of rstETH-Theta-Gauge tokens
    //User_Checkpoint?????? Only one I don't understand yet
    //Deposit - the function that allows
//}


interface IERC20 {
  function totalSupply() external view returns (uint256);

  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender)
    external view returns (uint256);

  function transfer(address to, uint256 value) external returns (bool);

  function approve(address spender, uint256 value)
    external returns (bool);

  function transferFrom(address from, address to, uint256 value)
    external returns (bool);

  event Transfer(
    address indexed from,
    address indexed to,
    uint256 value
  );

  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );
}


//DONT WORRY ABOUT READING THESE, I'VE COMMMENTED THE CODE ABOVE FOR READERS, THE COMMENTS BELOW ARE PERSONAL NOTES AND A BIG FRAGMENTED
//NOTES TO MYSELF:

  //Process for depositing Ribbon:
            //DepositETH - uses IRibbon interface
            //Read `RibbonVault.shares` - your shares only appear after 10:00 AM UTC on Fridays. 
            //stake - staking those shares - IRibbon
            //This function takes the shares that the caller has inside the vault 
            //NOTE THIS FUNCTION REDEEMS YOUR TOKENS AND THEN SENDS THEM ON THEIR WAY
                   //This function is called by the user:
                   //First it calls an approval for rstETH-Theta to be transferred
                   //Then it sends the rstETH-Theta to the Liquidity-Gauge using the ILiquidityGauge deposit function
                   //Finally, rstETH-Theta-Gauge is sent to the caller.
           

    //Process for withdrawing shit:
                   // Ribbon's contract for staking rstETH-Theta into rst-ETH-Theta-Gauge is an independent Vyper contract. You can stake off of the primary rstETH-Theta 
                   //contract but you cannot withdraw without interacting with the THETA-GAUGE contract.
                      //`Withdraw` called on rstETH-Theta-Gauge - IrstETH-Theta-Gauge
                                    //This function is called by the caller contract to interact with the rstETH-Theta-Gauge contract.
                                    //The caller contract is then sent rstETH-Theta
                                    //The rstETH-Theta-Gauge is then burned to 0x000
                                 // Unlike when initially depositing, the caller directly receives the rst-ETH - doesnt change the second layer
                  //Now our rstETH-Theta-Gauge is no longer tied up.
                  //move onto the two-step process of withdrawing from the main pool:
                       //Initializewithdraw - that is roughly the correct name
                            //Needs to happen before the next option is minted on Friday at 10:00 AM UTC. 
                       //CompleteWithdraw - roughly the correct name.
                             // Can occur after Friday at 10:00am UTC when your shares have been excluded from the new option. 

